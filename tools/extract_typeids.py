#!/usr/bin/env python3
"""
extract_typeids.py - Extract component TypeId addresses from macOS BG3 binary

Generates a C header file with all discovered TypeId addresses that can be
used to register components in BG3SE-macOS.

Usage:
    python3 tools/extract_typeids.py > generated_typeids.h

Or with custom binary path:
    python3 tools/extract_typeids.py /path/to/binary
"""

import subprocess
import re
import sys
from collections import defaultdict
from pathlib import Path

# Default binary path
DEFAULT_BINARY = "/Users/tomdimino/Library/Application Support/Steam/steamapps/common/Baldurs Gate 3/Baldur's Gate 3.app/Contents/MacOS/Baldur's Gate 3"

def extract_typeids(binary_path: str) -> dict:
    """Extract TypeId m_TypeIndex addresses from the binary."""

    # Run nm and c++filt
    cmd = f'nm -gU "{binary_path}" 2>/dev/null | c++filt'
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"Error running nm: {result.stderr}", file=sys.stderr)
        return {}

    # Pattern to match TypeId entries with ComponentTypeIdContext
    # Format: ADDRESS D ls::TypeId<COMPONENT, ecs::ComponentTypeIdContext>::m_TypeIndex
    pattern = re.compile(
        r'^([0-9a-f]+)\s+D\s+ls::TypeId<([^,]+),\s*ecs::ComponentTypeIdContext>::m_TypeIndex$'
    )

    components = {}

    for line in result.stdout.splitlines():
        # Skip guard variables
        if 'guard variable' in line:
            continue

        match = pattern.match(line)
        if match:
            address = int(match.group(1), 16)
            component_name = match.group(2).strip()

            # Skip non-component types
            if 'Component' not in component_name:
                continue

            components[component_name] = address

    return components

def categorize_components(components: dict) -> dict:
    """Categorize components by namespace."""
    categories = defaultdict(list)

    for name, addr in sorted(components.items()):
        # Extract namespace
        if '::' in name:
            ns = name.split('::')[0]
        else:
            ns = 'global'

        categories[ns].append((name, addr))

    return categories

def generate_header(components: dict) -> str:
    """Generate C header file with TypeId addresses."""

    categories = categorize_components(components)

    lines = []
    lines.append("/**")
    lines.append(" * generated_typeids.h - Auto-generated TypeId addresses")
    lines.append(" *")
    lines.append(" * Generated by tools/extract_typeids.py")
    lines.append(f" * Total components: {len(components)}")
    lines.append(" *")
    lines.append(" * NOTE: These are Ghidra addresses. To get runtime addresses:")
    lines.append(" *   runtime_addr = ghidra_addr - 0x100000000 + binary_base")
    lines.append(" */")
    lines.append("")
    lines.append("#ifndef GENERATED_TYPEIDS_H")
    lines.append("#define GENERATED_TYPEIDS_H")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("")

    # Statistics
    lines.append("// === Statistics ===")
    lines.append(f"// Total components: {len(components)}")
    for ns, comps in sorted(categories.items()):
        lines.append(f"// {ns}:: namespace: {len(comps)} components")
    lines.append("")

    # High-priority components (eoc:: namespace)
    eoc_components = categories.get('eoc', [])
    if eoc_components:
        lines.append("// === High-Priority Components (eoc:: namespace) ===")
        lines.append("// These are the most commonly used by mods")
        lines.append("")

        # Group eoc components by sub-namespace
        eoc_groups = defaultdict(list)
        for name, addr in eoc_components:
            parts = name.split('::')
            if len(parts) > 2:
                sub_ns = '::'.join(parts[:2])
            else:
                sub_ns = 'eoc'
            eoc_groups[sub_ns].append((name, addr))

        for sub_ns, comps in sorted(eoc_groups.items()):
            lines.append(f"// --- {sub_ns} ({len(comps)} components) ---")
            for name, addr in sorted(comps, key=lambda x: x[0]):
                # Create C-safe identifier
                c_name = name.replace('::', '_').upper()
                lines.append(f"#define TYPEID_{c_name} 0x{addr:x}ULL")
            lines.append("")

    # Other namespaces summary
    lines.append("// === Other Namespaces ===")
    for ns, comps in sorted(categories.items()):
        if ns == 'eoc':
            continue
        lines.append(f"// {ns}:: - {len(comps)} components (addresses available, layouts need discovery)")
    lines.append("")

    lines.append("#endif // GENERATED_TYPEIDS_H")

    return '\n'.join(lines)

def generate_summary(components: dict):
    """Print summary statistics."""
    categories = categorize_components(components)

    print("// === Component TypeId Summary ===", file=sys.stderr)
    print(f"// Total: {len(components)} components with TypeId addresses", file=sys.stderr)
    print("//", file=sys.stderr)

    for ns, comps in sorted(categories.items(), key=lambda x: -len(x[1])):
        print(f"// {ns}:: - {len(comps)} components", file=sys.stderr)

    print("//", file=sys.stderr)
    print("// BG3SE-macOS currently implements 36 components (~1.8% coverage)", file=sys.stderr)
    print("// High-priority target: 100-150 eoc:: components (~5-7% coverage)", file=sys.stderr)

def main():
    binary_path = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_BINARY

    if not Path(binary_path).exists():
        print(f"Error: Binary not found at {binary_path}", file=sys.stderr)
        sys.exit(1)

    components = extract_typeids(binary_path)

    if not components:
        print("Error: No components found", file=sys.stderr)
        sys.exit(1)

    # Generate summary to stderr
    generate_summary(components)

    # Generate header to stdout
    print(generate_header(components))

if __name__ == "__main__":
    main()
